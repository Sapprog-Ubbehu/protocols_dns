# DNS Caching Server

Этот проект реализует DNS-кеширующий сервер с поддержкой рекурсивных запросов к вышестоящему DNS, хранением записей на диске и удалением устаревших записей по TTL.

---


## Требования

* Python 3.7+
* Пакет [dnspython](https://www.dnspython.org/)

  ```bash
  pip install dnspython
  ```

## Конфигурация

В файле `dns_cache_server.py` при необходимости можно изменить:

* `CACHE_FILE` — путь к файлу кеша (по умолчанию `dns_cache.bin`)
* `UPSTREAM_DNS` — адрес вышестоящего DNS-сервера (по умолчанию Google `8.8.8.8:53`)
* `GC_INTERVAL` — интервал фоновой уборки просроченных записей (в секундах)

## Запуск

### Linux/macOS

Для запуска на Unix-системах с прослушиванием порта 53 (требуются root-права):

```bash
sudo python dns_cache_server.py
```

При старте вы увидите:

```
DNS-кеширующий сервер слушает порт 53
```

Остановить сервер можно сочетанием `Ctrl+C`. Кеш будет сохранен автоматически.

### Windows

На Windows запустите терминал от имени администратора:

1. Откройте PowerShell или CMD под администратором.
2. Перейдите в папку проекта, например:

   ```powershell
   cd C:/path/to/dns-cache-server
   ```
3. Установите зависимости:

   ```powershell
   pip install dnspython
   ```
4. Запустите сервер:

   ```powershell
   python dns_cache_server.py
   ```

Если порт 53 занят или вы столкнулись с ошибкой доступа, смените порт в коде:

* В файле `dns_cache_server.py` замените `srv.bind(("", 53))` на другой порт, например `( "", 5353 )`.
* При запросах указывайте новый порт:

  ```bash
  ```

dig @127.0.0.1 -p 5353 example.com A +norecurse

````

## Примеры использования

### Проверка кеширования через `dig`

1. Первый запрос (кеш пуст):
   ```bash
dig @127.0.0.1 example.com A +norecurse
````

Сервер пересылает запрос к UDP `8.8.8.8`, кеширует все ответы и возвращает клиенту.

2. Второй запрос (данные в кеше):

   ```bash
   ```

dig @127.0.0.1 example.com A +norecurse

````
   Ответ будет взят из кеша (с уменьшенным TTL).

3. Запрос несуществующего домена (ошибка):
   ```bash
dig @127.0.0.1 nosuchdomain.local A +norecurse
````

Если upstream не отвечает — возвращается `SERVFAIL`.

## Сохранение и загрузка кеша

* При старте сервер пытается загрузить кеш из файла `dns_cache.bin`.
* При остановке (Ctrl+C) кеш сохраняется обратно.
* Формат файла — сериализованный словарь Python через `pickle`.

## Описание кода

* **DnsCache**

  * Хранит записи в памяти: ключ `(name, rdtype, rdclass)` → список `(RRset, expire_time)`.
  * Методы:

    * `get(name, rdtype, rdclass)` — возвращает список актуальных RRset с TTL.
    * `put(rrset)` — добавляет или обновляет запись с вычислением `expire_time = now + ttl`.
    * `gc()` — фоновая уборка просроченных записей.
  * Сериализует кеш на диск (`pickle`).

* **handle\_query**

  * Принимает пакет DNS, разбирает вопрос.
  * Пытается ответить из кеша; если нет — пересылает к upstream с таймаутом (2 с).
  * Кеширует все RR из разделов `answer`, `authority`, `additional`.
  * В случае таймаута upstream ставит код ошибки `SERVFAIL`.

* **Основной скрипт**

  * Создаёт UDP-сокет на порту 53.
  * Для каждого запроса создаёт поток `threading.Thread`.
  * Запускает фоновый GC-поток.
